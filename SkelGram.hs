module SkelGram where

-- Haskell module generated by the BNF converter

import System.IO
import Control.Monad.State

import AbsGram
import ErrM
type Result a = StateT [Value] IO a

failure :: Show a => a -> Result ()
failure x = do
  liftIO $ putStrLn $ show x
--   return ()-- Bad $ "Undefined case: " ++ show x
{-
transIdent :: Ident -> Result
transIdent x = case x of
  Ident string -> failure x -}
transProgram :: Program -> Result ()
transProgram x = case x of
  Program stmts -> transStmts stmts
{-
transBlock :: Block -> Result
transBlock x = case x of
Block stmts -> failure x-}
transStmts :: [Stmt] -> Result ()
transStmts = mapM_ transStmt

declItem :: Type -> Item -> Result()
declItem t (NoInit i) = do
  modify $ \env -> (MyInt 0):env
declItem t (Init i e) = do
  v <- transExpr e
  modify $ \env -> v:env
-- napisac tranExpr - wyliczac podstawowe wartosci
-- zeby ^ wpisywal do stanu dobrze

-- potem robimy mapÄ™ Data.mapM Ident->Wartosc (VAL)
-- Eval
transStmt :: Stmt -> Result ()
transStmt x = case x of
  Empty -> return ()	
  BStmt block -> failure x
  Decl type_ items -> mapM_ (declItem type_) items
  Ass ident expr -> failure x
  Incr ident -> failure x
  Decr ident -> failure x
  Ret expr -> failure x
  VRet -> failure x
  Cond expr stmt -> failure x
  CondElse expr stmt1 stmt2 -> failure x
  While expr stmt -> failure x
  Debug -> do
	  liftIO $ putStrLn "uwaga teraz debuguje"
	  state <- get
	  liftIO $ putStrLn $ show state
  SExp expr -> failure x

{-
transItem :: Item -> Result
transItem x = case x of
  NoInit ident -> failure x
  Init ident expr -> failure x
transType :: Type -> Result
transType x = case x of
  Int -> failure x
  Str -> failure x
  Bool -> failure x
  Void -> failure x
  Ref type_ -> failure x
  Fun type_ types -> failure x
-}

data Value = MyInt Int -- |
instance Show Value where
	show (MyInt x) = show x

transExpr :: Expr -> Result Value
transExpr x = case x of
--  ELam type_ types block -> failure x
--  EVar ident -> failure x
  ELitInt integer -> return $ MyInt $ fromInteger integer
--  ELitTrue -> failure x
--   ELitFalse -> failure x
--   EApp ident exprs -> failure x
--   EString string -> failure x
--   Neg expr -> failure x
--   Not expr -> failure x
--   EMul expr1 mulop expr2 -> failure x
--   EAdd expr1 addop expr2 -> failure x
--   ERel expr1 relop expr2 -> failure x
--   EAnd expr1 expr2 -> failure x
--   EOr expr1 expr2 -> failure x
{-
transAddOp :: AddOp -> Result
transAddOp x = case x of
  Plus -> failure x
  Minus -> failure x
transMulOp :: MulOp -> Result
transMulOp x = case x of
  Times -> failure x
  Div -> failure x
  Mod -> failure x
transRelOp :: RelOp -> Result
transRelOp x = case x of
  LTH -> failure x
  LE -> failure x
  GTH -> failure x
  GE -> failure x
  EQU -> failure x
  NE -> failure x

  -}
